Предложенное решение осуществляет отображение графа объектов в последовательность байтов, предоставляя функционал в виде библиотеки классов и консольной утилиты.

Предложены правила сериализации значений различных типов данных (Converter), в том числе:
 - целочисленные типы - отображаются в последовательность байтов, не длиннее или не многим длиннее количества, необходимого для хранения конкретного значения, а не типа;
 - строковые данные - отображаются в байты, представляющие эти данные в экономичной и полной кодировке UTF-8. Длины строк не объявляются, вместо этого используется терминирующий символ \0, что, например, предположительно, в перспективе позволит подменять эти строковые значения на локализованные непосредственно в сериализованном потоке, как, например, поступает библиотека i18n. При этом, естественно, в исходных данных присутствие символов \0 не допускается.

Описаны механизмы сбора графа объектов (ContractGraphReader). Объекты требуют предварительную подготовку в виде добавления атрибутов к свойствам и полям контрактов, по типу protobuf-net. Механизм сбора графа объектов един для сериализации и десериализации, другими словами, и при известном значении объекта, и при несуществующем объекте. Отсюда проистекает важное ограничение: не поддерживаются и, более того, не детектируются, циклы в графе типов, а не только объектов: сбор графа по подобному контракту - class A { public A A; } - приведет к бесконечному "проваливанию" в описание типа А и исключению StackOverflowException.

Сформулированы правила представления в потоке байтов структуры графа объектов.

Очевидно, что, коль скоро граф объектов не имеет отношения к конкретным значениям объектов, особой обработки также потребовали списки значений, за пределами слоя сбора графа объектов, при этом обработчики сериализации и десериализации списка производят сбор подграфов объектов для каждого значения списка.

Предложенное решение не зависит от кокретной реализации потока Stream, в частности, не использует API seekable потоков.

API библиотеки позволяет вызывающему коду переопределять правила конечной сериализации значений конкретных типов (Converter), при этом, в качестве типов могут выступать и сложные типы, и списки. Также существует возможность описать Converter значения не в последовательность байтов, а в объект другого типа, для которого в свою очередь должен быть разрешен и вызван Converter. Подобная цепочка может быть сколь угодно длинной. В примерах приведены два Converters, реализующих в цепочке сериализацию строк, возможно имеющих символы \0, не поддерживаемые встроенным Converter.

Отсутствуют дескрипторы типов, соответственно, все значения сериализуются и десериализуются в соответствии с объявленными типами.

Отсутствует поддержка Nullable типов, и реализовать их в виде части настраиваемого слоя Converters представляется невозможным, учитывая его обобщенность, однако код клиента может предоставить Converter конкретного, закрытого, необходимого ему, типа Nullable<T>. По схожим причинам затруднена обработка на этом слое перечислений enum, а именно, десериализация. Но опять же, код клиента может описать правила обработки конкретных типов перечислений. Так или иначе, обработка этих типов может быть поддержана в слоях ConvertingDeserializationExecutor и StreamEntriesProvider, но они неконфигурируемые клиентским кодом, то есть, эта поддержка должна быть реализована в самой библиотеке. Другая возможность - сделать более гибким описание Converter, чтобы была возможность сделать его объявляющим конвертирующий тип только частично, а полный, настоящий тип должен стать доступен для анализа самому Converter в контексте обработки конкретного значения.

Решение кросплатформенное, имеющиеся demo-обработки и тесты успешно запущены в среде исполнения mono в ОС Linux.